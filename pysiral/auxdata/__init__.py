# -*- coding: utf-8 -*-
"""
Created on Fri May 19 14:42:35 2017

@author: Stefan
"""

__all__ = ["AuxdataBaseClass",
           "AuxClassConfig",
           "GridTrackInterpol",
           "get_all_auxdata_classes",
           "ml",
           "mss",
           "icechart",
           "rio",
           "sic",
           "sitype",
           "snow",
           "region"]


import re
from datetime import date
from pathlib import Path
from typing import List

import numpy as np
import scipy.ndimage as ndimage
from attrdict import AttrDict
from pyproj import Proj

from pysiral import import_submodules
from pysiral.core.errorhandler import ErrorStatus
from pysiral.l1data import L1bdataNCFile


class AuxdataBaseClass(object):
    """
    Base class for all subtype auxdata base classes (e.g. SICBaseClass).
    This class defines the mandatory set of methods and properties for all
    auxdata classes
    """

    def __init__(self, auxclass_cfg):
        """ This class should not be called directly, only its subclasses. auxclass_cfg needs to be of type
        AuxClassConfig """

        # Error handler
        self.error = ErrorStatus(self.pyclass)

        # Auxiliary class options
        if not isinstance(auxclass_cfg, AuxClassConfig):
            msg = "Invalid config object: %s (needs to be of type pysiral.auxdata.AuxClassConfig"
            msg %= str(auxclass_cfg)
            self.error.add_error("invalid-auxclasscfg-type", msg)
            self.error.raise_on_error()
        self._cfg = auxclass_cfg

        # Main properties
        self._data = None     # Data container for external data
        self._auxvars = []    # List of auxiliary variables generated by the child class

        # General messages
        self.msgs = []

        # --- Class internals ---

        # This is for auxiliary data handlers that require to read external product files for
        # a defined period (daily, monthly, ...). The implementation currently keeps only one
        # external product in memory at the time. The period (date list: yyyy, mm, dd) of this
        # currently loaded product is designated as current_date  This date is compared to the
        # requested date and if a new product is loaded upon mismatch of current & requested data
        # NOTE: This will be bypassed by static auxiliary data classes
        # TODO: Load all auxiliary products for processing period in memory (allow parallel processing)
        # TODO: Add actual periods, e.g. for trajectory based auxiliary data
        self._current_date = [0, 0, 0]
        self._requested_date = [-1, -1, -1]

    def set_requested_date(self, year, month, day):
        """ Use first timestamp as reference, date changes are ignored """
        self._requested_date = [year, month, day]

    def set_requested_date_from_l2(self, l2):
        """ Convenience method, Use first timestamp as reference, date changes are ignored """
        year = l2.track.timestamp[0].year
        month = l2.track.timestamp[0].month
        day = l2.track.timestamp[0].day
        self.set_requested_date(year, month, day)

    def check_data_availability(self, data_container_name="_data"):
        """
        Checks if data is loaded. If data container is None, raise an Error
        :param data_container_name:
        :return:
        """
        data_container = getattr(self, data_container_name, None)
        if data_container is None:
            msg = "%s: Data not loaded [%s]"
            msg %= (self.__class__.__name__, f"{self.year}-{self.month}-{self.day}")
            self.add_handler_message(msg)
            self.error.add_error("auxdata_missing", msg)

    def reset_auxvars(self):
        """ Empties the auxiliary data store. To be executed during class initialization and
        before retrieving data (e.g. since the Level-2 processor calls this instance repeatedly) """
        self._auxvars = []

    def reset_handler_messages(self):
        """ Empties the message list. To be executed during class initialization and
        before retrieving data (e.g. since the Level-2 processor calls this instance repeatedly) """
        self.msgs = []

    def receive_l1p_input(self, l1p: 'L1bdataNCFile') -> None:
        """
        An optional method to pass l1p information to the auxiliary data class prior
        to execution. For this method to work it needs to be overwritten to by the child class.
        :param l1p:
        :return:
        """
        pass

    def add_variables_to_l2(self, l2):
        """ Main Access points for the Level-2 Processor """

        # Call the API get_track class. This is the mandatory method of all auxiliary subclasses (independent
        # of type). Test if this is indeed the case
        if not self.has_mandatory_track_method:
            msg = f"Mandatory subclass method `get_l2_track_vars` not implemented for {self.pyclass} "

            self.error.add_error("not-implemented", msg)
            self.error.raise_on_error()

        # Before calling the get_track_vars of the subclass, we must empty any existing data from a potential
        # previous execution
        self.reset_auxvars()
        self.reset_handler_messages()

        # Call the mandatory track extraction method. Each subclass should register its output via the
        # `register_auxvar` method of the parent class
        self.get_l2_track_vars(l2)

        # Check on errors
        if self.error.status and self.exception_on_error:
            self.error.raise_on_error()

        # Update the Level-2 object
        try:
            self.update_l2(l2)
        except KeyError:
            msg = f"Invalid auxiliary parameter return from class {self.pyclass}"
            self.error.add_error("invalid-auxvar-return", msg)
            self.error.raise_on_error()

    def register_auxvar(self, var_id, var_name, value, uncertainty=None):
        """ Register an auxiliary variable. The different parameters are necessary for the L2 data object.
        When it will be added to the l2 object in self.update_l2, the variable will be accessible from the l2 with
        the following expressions:

            value = l2.%var_id%
            uncertainty = l2.%var_id%.uncertainty

        or

            value = l2.get_parameter_by_name(%var_name%)
            uncertainty = l2.get_parameter_by_name(%var_name%_uncertainty)
        """
        auxvar_dict = dict(id=var_id, name=var_name, value=value, uncertainty=uncertainty)
        self._auxvars.append(auxvar_dict)

    def add_handler_message(self, msg):
        self.msgs.append(msg)

    @staticmethod
    def get_empty_array(l2, empty_val=np.nan):
        return np.full(l2.n_records, empty_val)

    def update_external_data(self):
        """
        This method will check if the requested date matches current data
        and call the subclass data loader method if not

        :return:
        """

        # Check if data for day is already loaded
        if self._requested_date != self._current_date:
            # NOTE: The implementation of this method needs to be in the subclass
            self.load_requested_auxdata()
            self._current_date = self._requested_date
            if self.has_data_loaded:
                self.add_handler_message(self.__class__.__name__ + ": Load "+str(self.requested_filepath))
        else:
            if self.has_data_loaded:
                self.add_handler_message(self.__class__.__name__+": Data already present")
            else:
                msg = ": No Data: Loading failed in an earlier attempt"
                self.add_handler_message(self.__class__.__name__ + msg)

    def load_requested_auxdata(self):
        """
        This method raises a NotImplementedError if it is not overwritten by child class
        :return:
        """
        msg = """
        This Exception is caused because the auxiliary data class ({}) is missing the method `load_requested_auxdata`
        or AuxdataBaseClass was called directly (which it should not)"""
        msg = msg.format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def get_l2_track_vars(self, *args):
        """
        This method raises a NotImplementedError if it is not overwritten by child class
        :return:
        """
        msg = """
        This Exception is caused because the auxiliary data class ({}) is missing the method `get_l2_track_vars`
        or AuxdataBaseClass was called directly (which it should not)"""
        msg = msg.format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def update_l2(self, l2):
        """ Automatically add all auxiliary variables to a Level-2 data object"""
        for auxvar in self._auxvars:
            uncertainty = auxvar.get("uncertainty", None)
            l2.set_auxiliary_parameter(auxvar["id"], auxvar["name"], auxvar["value"], uncertainty)

    @property
    def pyclass(self) -> str:
        return self.__class__.__name__

    @property
    def cfg(self):
        return self._cfg

    @property
    def has_data_loaded(self) -> bool:
        return self._data is not None if hasattr(self, "_data") else False

    @property
    def exception_on_error(self) -> bool:
        return self.cfg.options.get("exception_on_error", False)

    @property
    def requested_filepath(self) -> "Path":
        """
        Returns the local file path for the requested date
        :return:
        """

        # Main directory
        path = Path(self.cfg.local_repository)

        # Add the sub-folders
        for subfolder_tag in self.cfg.subfolders:
            subfolder = getattr(self, subfolder_tag)
            path = path / subfolder

        # Get the period dict (will be constructed from filenaming)
        period_dict = {}
        attrs = re.findall("{.*?}", self.cfg.filenaming)
        for attr_def in attrs:
            attr_name = attr_def[1:-1]
            period_dict[attr_name] = getattr(self, attr_name)
        filename = self.cfg.filenaming.format(**period_dict)
        path = path / filename
        return path

    @property
    def year(self):
        return "%04g" % self._requested_date[0]

    @property
    def month(self):
        return "%02g" % self._requested_date[1]

    @property
    def day(self):
        return "%02g" % self._requested_date[2]

    @property
    def requested_date(self) -> date:
        return date(*self._requested_date)

    @property
    def has_mandatory_track_method(self):
        """ Test if this object instance has the mandatory method for extracting track data. This method
        is named get_l2_track_vars() and needs to be present in any auxiliary subclass"""
        get_track_children_method = getattr(self, "get_l2_track_vars", None)
        return callable(get_track_children_method)

    @property
    def auxvar_names(self):
        return [auxvar["name"] for auxvar in self._auxvars]


class AuxClassConfig(object):
    """
    A container for configuration data for any auxilary data handler class
    #TODO: Quite outdated structure
    """

    def __init__(self,
                 options: dict = None,
                 local_repository: str = None,
                 filename: str = None,
                 filenaming: str = None,
                 subfolders: List[str] = None,
                 long_name: str = ""
                 ) -> None:
        """
        Data class for an auxilary class configuration data
        :param options: Dictionary holding the class configuration data as dictionary
            (merged keys from auxdata_def.yaml and Level-2 processor definition)
        :param local_repository: Key poin
        :param filename: static filename (if applicable)
        :param filenaming: Template for a filename with custom keys (if applicable)
        :param subfolders: List of subfolders
        :param long_name: Documentation string.
        """

        # General options
        self.options = options
        self.local_repository = local_repository
        self.filename = filename
        self.filenaming = filenaming
        self.subfolders = subfolders if subfolders is not None else []
        self.long_name = long_name

    def set_long_name(self, docstr: str) -> None:
        """
        Set a description of the auxdata source
        :param docstr:
        :return:
        """
        self.long_name = docstr

    def set_options(self, **opt_dict: dict) -> None:
        """
        Pass a dictionary with options
        :param opt_dict:
        :return:
        """
        if self.options is None:
            self.options = AttrDict(**opt_dict)
        else:
            self.options.update(AttrDict(**opt_dict))

    def set_local_repository(self, path: str) -> None:
        """
        Set the path the local auxdata repository
        :param path:
        :return:
        """
        self.local_repository = path

    def set_filename(self, filename: str) -> None:
        """
        Set a constant filename (e.g. for mss)
        :param filename:
        :return:
        """
        self.filename = filename

    def set_filenaming(self, filenaming: str) -> None:
        """
        Set the filenaming of the auxdata files
        :param filenaming:
        :return:
        """
        self.filenaming = filenaming

    def set_subfolder(self, subfolder_list: List[str]) -> None:
        """
        Set a list of folders (year, [month, [day]]) where auxdata files  can be found
        :param subfolder_list:
        :return:
        """
        self.subfolders = subfolder_list

    @property
    def option_keys(self):
        return self.options.keys()


# TODO: Deprecate this class -> Use pysiral.grid.GridImageExtract
class GridTrackInterpol(object):
    """ Implements fast extraction of gridded data along a track using Image Interpolation """

    def __init__(self, lons, lats, grid_lons, grid_lats, griddef):
        """
        lons, lats: ground track
        Example grid definition (dict)
            projection:
                proj: stere
                ellps: WGS84
                lon_0: 0
                lat_0: -90
                lat_ts: -70
                a: 6378273
                b: 6356889.44891
            dimension:
                n_cols: 632
                n_lines: 664
                dx: 12500
                dy: 12500
        """

        # Save the arguments
        self.lons = lons
        self.lats = lats
        self.grid_lons = grid_lons
        self.grid_lats = grid_lats
        self.griddef = AttrDict(**griddef)

        # Compute image coordinates
        self._set_projection()
        self._get_track_image_coordinates()

    def _set_projection(self):
        self.p = Proj(**self.griddef.projection)

    def _get_track_image_coordinates(self):
        """ Computes the image coordinates that will be used for the m"""

        # Convert track coordinates to grid projection coordinates
        tr_x, tr_y = self.p(self.lons, self.lats)

        # Convert grid coordinates to grid projection coordinates
        x, y = self.p(self.grid_lons, self.grid_lats)

        # Convert track projection coordinates to image coordinates
        # x: 0 < n_lines; y: 0 < n_cols
        dim = self.griddef.dimension
        x_min, y_min = np.nanmin(x), np.nanmin(y)
        self.ix, self.iy = (tr_x-x_min)/dim.dx, (tr_y-y_min)/dim.dy

    def get_from_grid_variable(self, gridvar, order=0, flipud=False):
        """ Returns a along-track data from a grid variable"""
        if flipud:
            gridvar = np.flipud(gridvar)
        return ndimage.map_coordinates(gridvar, [self.iy, self.ix], order=order)

    def debug_map(self, *args, **kwargs):
        raise NotImplementedError()
        # track_var = self.get_from_grid_variable(*args, **kwargs)


def get_all_auxdata_classes():
    """
    Get a list of all auxiliary data classes
    :return: List with auxdata_type, class_name, class for each auxiliary class
    """

    # Import all submodules of the auxdata module to discover all potential
    # subclasses of AuxdataBaseClass
    import_submodules(__name__)

    # Get a list of AuxdataBaseClass subclasses after import
    subclass_list = AuxdataBaseClass.__subclasses__()

    # Compile output
    auxdata_class_results = []
    for item in subclass_list:
        module = item.__module__.split(".")[-1]
        class_name = item.__name__
        auxdata_class_results.append([module, class_name, item])
    return auxdata_class_results
