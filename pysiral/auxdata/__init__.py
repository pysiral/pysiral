# -*- coding: utf-8 -*-
"""
Created on Fri May 19 14:42:35 2017

@author: Stefan
"""

__all__ = ["AuxdataBaseClass", "GridTrackInterpol", "get_all_auxdata_classes", "mss", "icechart", "rio", "sic",
           "sitype", "snow", "region"]


import re

import numpy as np
from typing import List
from attrdict import AttrDict

import scipy.ndimage as ndimage
from pathlib import Path
from pyproj import Proj

from pysiral import import_submodules
from pysiral.errorhandler import ErrorStatus


class AuxdataBaseClass(object):
    """
    Base class for all sub-type auxdata base classes (e.g. SICBaseClass).
    This class defines the mandatory set of methods and properties for all
    auxdata classes
    """

    def __init__(self, auxclass_cfg):
        """ This class should not be called directly, only its subclasses. auxclass_cfg needs to be of type
        AuxClassConfig """

        # Error handler
        self.error = ErrorStatus(self.pyclass)

        # Auxiliary class options
        if not isinstance(auxclass_cfg, AuxClassConfig):
            msg = "Invalid config object: %s (needs to be of type pysiral.auxdata.AuxClassConfig"
            msg = msg % str(auxclass_cfg)
            self.error.add_error("invalid-auxclasscfg-type", msg)
            self.error.raise_on_error()
        self._cfg = auxclass_cfg

        # Main properties
        self._data = None     # Data container for external data
        self._auxvars = []    # List of auxiliary variables generated by the child class

        # General messages
        self.msgs = []

        # --- Class internals ---

        # This is for auxiliary data handlers that require to read external product files for
        # a defined period (daily, monthly, ...). The implementation currently keeps only one
        # external product in memory at the time. The period (date list: yyyy, mm, dd) of this
        # currently loaded product is designated as current_date  This date is compared to the
        # requested date and if a new product is loaded upon mismatch of current & requested data
        # NOTE: This will be bypassed by static auxiliary data classes
        # TODO: Load all auxiliary products for processing period in memory (allow parallel processing)
        self._current_date = [0, 0, 0]
        self._requested_date = [-1, -1, -1]

    def set_requested_date(self, year, month, day):
        """ Use first timestamp as reference, date changes are ignored """
        self._requested_date = [year, month, day]

    def set_requested_date_from_l2(self, l2):
        """ Convenience method, Use first timestamp as reference, date changes are ignored """
        year = l2.track.timestamp[0].year
        month = l2.track.timestamp[0].month
        day = l2.track.timestamp[0].day
        self.set_requested_date(year, month, day)

    def check_data_availability(self, data_container_name="_data"):
        """
        Checks if data is loaded. If data container is None, raise an Error
        :param data_container_name:
        :return:
        """
        data_container = getattr(self, data_container_name, None)
        if data_container is None:
            msg = "%s: Data not loaded [%s]"
            msg = msg % (self.__class__.__name__, self.year+"-"+self.month+"-"+self.day)
            self.add_handler_message(msg)
            self.error.add_error("auxdata_missing", msg)

    def reset_auxvars(self):
        """ Empties the auxiliary data store. To be executed during class initialization and
        before retrieving data (e.g. since the Level-2 processor calls this instance repeatedly) """
        self._auxvars = []

    def reset_handler_messages(self):
        """ Empties the message list. To be executed during class initialization and
        before retrieving data (e.g. since the Level-2 processor calls this instance repeatedly) """
        self.msgs = []

    def add_variables_to_l2(self, l2):
        """ Main Access points for the Level-2 Processor """

        # Call the API get_track class. This is the mandatory method of all auxiliary subclasses (independent
        # of type. Test if this is indeed the case
        if not self.has_mandatory_track_method:
            msg = "Mandatory subclass method `get_l2_track_vars` not implemented for %s " % self.pyclass
            self.error.add_error("not-implemented", msg)
            self.error.raise_on_error()

        # Before calling the get_track_vars of the subclass, we must empty any existing data from a potential
        # previous execution
        self.reset_auxvars()
        self.reset_handler_messages()

        # Call the mandatory track extraction method. Each subclass should register its output via the
        # `register_auxvar` method of the parent class
        self.get_l2_track_vars(l2)

        # Check on errors
        if self.error.status and self.exception_on_error:
            self.error.raise_on_error()

        # Update the Level-2 object
        try:
            self.update_l2(l2)
        except KeyError:
            msg = "Invalid auxiliary parameter return from class %s" % self.pyclass
            self.error.add_error("invalid-auxvar-return", msg)
            self.error.raise_on_error()

    def register_auxvar(self, var_id, var_name, value, uncertainty=None):
        """ Register an auxiliary variable. The different parameters are necessary for the L2 data object.
        When it will be added to the l2 object in self.update_l2, the variable will be accessible from the l2 with
        the following expressions:

            value = l2.%var_id%
            uncertainty = l2.%var_id%.uncertainty

        or

            value = l2.get_parameter_by_name(%var_name%)
            uncertainty = l2.get_parameter_by_name(%var_name%_uncertainty)
        """
        auxvar_dict = dict(id=var_id, name=var_name, value=value, uncertainty=uncertainty)
        self._auxvars.append(auxvar_dict)

    def add_handler_message(self, msg):
        self.msgs.append(msg)

    @staticmethod
    def get_empty_array(l2, empty_val=np.nan):
        return np.full(l2.n_records, empty_val)

    def update_external_data(self):
        """ This method will check if the requested date matches current data
        and call the subclass data loader method if not """
        # Check if data for day is already loaded
        if self._requested_date != self._current_date:
            # NOTE: The implementation of this method needs to be in the subclass
            self.load_requested_auxdata()
            self._current_date = self._requested_date
            if self.has_data_loaded:
                self.add_handler_message(self.__class__.__name__ + ": Load "+str(self.requested_filepath))
        else:
            if self.has_data_loaded:
                self.add_handler_message(self.__class__.__name__+": Data already present")
            else:
                msg = ": No Data: Loading failed in an earlier attempt"
                self.add_handler_message(self.__class__.__name__ + msg)

    def load_requested_auxdata(self):
        """
        This methods raises a NotImplementedError if it is not overwritten by child class
        :return:
        """
        msg = """
        This Exception is caused because the auxiliary data class ({}) is missing the method `load_requested_auxdata`
        or AuxdataBaseClass was called directly (which it should not)"""
        msg = msg.format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def get_l2_track_vars(self, *args):
        """
        This methods raises a NotImplementedError if it is not overwritten by child class
        :return:
        """
        msg = """
        This Exception is caused because the auxiliary data class ({}) is missing the method `get_l2_track_vars`
        or AuxdataBaseClass was called directly (which it should not)"""
        msg = msg.format(self.__class__.__name__)
        raise NotImplementedError(msg)

    def update_l2(self, l2):
        """ Automatically add all auxiliary variables to a Level-2 data object"""
        for auxvar in self._auxvars:
            uncertainty = auxvar.get("uncertainty", None)
            l2.set_auxiliary_parameter(auxvar["id"], auxvar["name"], auxvar["value"], uncertainty)

    @property
    def pyclass(self):
        return self.__class__.__name__

    @property
    def cfg(self):
        return self._cfg

    @property
    def has_data_loaded(self):
        if not hasattr(self, "_data"):
            return False
        return self._data is not None

    @property
    def exception_on_error(self):
        if "exception_on_error" in self.cfg.options:
            exception_on_error = self.cfg.options.exception_on_error
        else:
            exception_on_error = False
        return exception_on_error

    @property
    def requested_filepath(self):
        """ Returns the local file path for the requested date"""

        # Main directory
        path = Path(self.cfg.local_repository)

        # Add the subfolders
        for subfolder_tag in self.cfg.subfolders:
            subfolder = getattr(self, subfolder_tag)
            path = path / subfolder

        # Get the period dict (will be constructed from filenaming)
        period_dict = {}
        attrs = re.findall("{.*?}", self.cfg.filenaming)
        for attr_def in attrs:
            attr_name = attr_def[1:-1]
            period_dict[attr_name] = getattr(self, attr_name)
        filename = self.cfg.filenaming.format(**period_dict)
        path = path / filename
        return path

    @property
    def year(self):
        return "%04g" % self._requested_date[0]

    @property
    def month(self):
        return "%02g" % self._requested_date[1]

    @property
    def day(self):
        return "%02g" % self._requested_date[2]

    @property
    def has_mandatory_track_method(self):
        """ Test if this object instance has the mandatory method for extracting track data. This method
        is named get_l2_track_vars() and needs to be present in any auxiliary subclass"""
        has_method = False
        get_track_children_method = getattr(self, "get_l2_track_vars", None)
        if callable(get_track_children_method):
            has_method = True
        return has_method

    @property
    def auxvar_names(self):
        return list([auxvar["name"] for auxvar in self._auxvars])


class AuxClassConfig(object):
    """
    A container for configuration data for any auxilary data handler class
    #TODO: Quite outdated structure
    """

    def __init__(self,
                 options: dict = None,
                 local_repository: str = None,
                 filename: str = None,
                 filenaming: str = None,
                 subfolders: List[str] = None,
                 long_name: str = ""
                 ) -> None:
        """
        Data class for an auxilary class configuration data
        :param options: Dictionary holding the class configuration data as dictionary
            (merged keys from auxdata_def.yaml and Level-2 processor definition)
        :param local_repository: Key poin
        :param filename: static filename (if applicable)
        :param filenaming: Template for a filename with custom keys (if applicable)
        :param subfolders: List of subfolders
        :param long_name: Documentation string.
        """

        # General options
        self.options = options
        self.local_repository = local_repository
        self.filename = filename
        self.filenaming = filenaming
        self.subfolders = subfolders if subfolders is not None else []
        self.long_name = long_name

    def set_long_name(self, docstr: str) -> None:
        """
        Set a description of the auxdata source
        :param docstr:
        :return:
        """
        self.long_name = docstr

    def set_options(self, **opt_dict: dict) -> None:
        """
        Pass a dictionary with options
        :param opt_dict:
        :return:
        """
        if self.options is None:
            self.options = AttrDict(**opt_dict)
        else:
            self.options.update(AttrDict(**opt_dict))

    def set_local_repository(self, path: str) -> None:
        """
        Set the path the local auxdata repository
        :param path:
        :return:
        """
        self.local_repository = path

    def set_filename(self, filename: str) -> None:
        """
        Set a constant filename (e.g. for mss)
        :param filename:
        :return:
        """
        self.filename = filename

    def set_filenaming(self, filenaming: str) -> None:
        """
        Set the filenaming of the auxdata files
        :param filenaming:
        :return:
        """
        self.filenaming = filenaming

    def set_subfolder(self, subfolder_list: List[str]) -> None:
        """
        Set a list of folders (year, [month, [day]]) where auxdata files  can be found
        :param subfolder_list:
        :return:
        """
        self.subfolders = subfolder_list


class GridTrackInterpol(object):
    """ Implements fast extraction of gridded data along a track using Image Interpolation """

    def __init__(self, lons, lats, grid_lons, grid_lats, griddef):
        """
        lons, lats: ground track
        Example grid definition (dict)
            projection:
                proj: stere
                ellps: WGS84
                lon_0: 0
                lat_0: -90
                lat_ts: -70
                a: 6378273
                b: 6356889.44891
            dimension:
                n_cols: 632
                n_lines: 664
                dx: 12500
                dy: 12500
        """

        # Save the arguments
        self.lons = lons
        self.lats = lats
        self.grid_lons = grid_lons
        self.grid_lats = grid_lats
        self.griddef = AttrDict(**griddef)

        # Compute image coordinates
        self._set_projection()
        self._get_track_image_coordinates()

    def _set_projection(self):
        self.p = Proj(**self.griddef.projection)

    def _get_track_image_coordinates(self):
        """ Computes the image coordinates that will be used for the m"""

        # Convert track coordinates to grid projection coordinates
        tr_x, tr_y = self.p(self.lons, self.lats)

        # Convert grid coordinates to grid projection coordinates
        x, y = self.p(self.grid_lons, self.grid_lats)

        # Convert track projection coordinates to image coordinates
        # x: 0 < n_lines; y: 0 < n_cols
        dim = self.griddef.dimension
        x_min, y_min = np.nanmin(x), np.nanmin(y)
        self.ix, self.iy = (tr_x-x_min)/dim.dx, (tr_y-y_min)/dim.dy

    def get_from_grid_variable(self, gridvar, order=0, flipud=False):
        """ Returns a along-track data from a grid variable"""
        if flipud:
            gridvar = np.flipud(gridvar)
        trackvar = ndimage.map_coordinates(gridvar, [self.iy, self.ix], order=order)
        return trackvar

    def debug_map(self, *args, **kwargs):
        raise NotImplementedError()
        # track_var = self.get_from_grid_variable(*args, **kwargs)


def get_all_auxdata_classes():
    """
    Get a list of all auxiliary data classes
    :return: List with auxdata_type, class_name, class for each auxiliary class
    """

    # Import all submodules of the auxdata module to discover all potential
    # subclasses of AuxdataBaseClass
    import_submodules(__name__)

    # Get a list of AuxdataBaseClass subclasses after import
    subclass_list = AuxdataBaseClass.__subclasses__()

    # Compile output
    auxdata_class_results = []
    for item in subclass_list:
        module = item.__module__.split(".")[-1]
        class_name = item.__name__
        auxdata_class_results.append([module, class_name, item])
    return auxdata_class_results
