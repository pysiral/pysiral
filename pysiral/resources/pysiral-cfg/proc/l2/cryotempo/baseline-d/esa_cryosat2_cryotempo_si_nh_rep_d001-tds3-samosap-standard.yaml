metadata:
    label: "ESA CryoTEMPO CryoSat-2 reprocessed sea ice product"
    product_line: esa
    record_type: tds-si-rep-D001-TDS3-samosa-standard
    platform: cryosat2
    version: D001
    file_version_tag: "D001-TDS3b"
    hemisphere: north


# --- Ingest auxiliary data ---
#
# A list auxilliary datasets to be ingested before the execution of the processing steps.
#
# Usage:
#
#  - <auxdata_category>:       <- links to corresponding category in auxdata_def.yaml
#       name: <auxdata_name>   <- links auxdata_category.auxdata_name auxdata_def.yaml
#       options: {dict}        <- Options that may overwrite the ones already provided in auxdata_def.yaml
#
# Notes:
#
#   - The order of the auxdata definition is important as there might be dependancies of auxiliary datasets
#
auxdata:

    # Add region codes
    # NOTE: It is advisable to do this in the beginning, since the following auxiliary data types can
    #       be modified depending on region code
    - region:
        name: nsidc_2021
        options: null

    # Load the
    - mss:
        name: dtu21
        options:
            latitude_range: [45.0, 90.0]

    - sic:
        name: c3s
        options:
            version: v3p0
            exception_on_error: True

    - sitype:
        name: c3s
        options:
            version: v3p0
            fill_valid_sic_gaps: True
            exception_on_error: True

    - snow:
        name: clim_w99amsr2
        options:
            daily_scaling: True
            fyi_correction_factor: 0.5
            exception_on_error: False

    # Note: The snow density in this class will overwrite the snow density
    #       from the W99/AMSR2 climatology (this is intended)
    - snow:
            name: snow_density_seasonal_mallett
            options:
                snow_density_uncertainty: 50.


# --- Level-2 processor steps ---
#
# A list auxilliary datasets to be ingested before the execution of the processing steps.

procsteps:

    # Transfer variables from the l1b data object to the l2 data object
    # Notation is:
    #
    # <l1b_datagroup>:
    #        <l1b_variable_name>: [l2_auxdata_id, l2_auxdata_name]
    -   module: l2proc.procsteps
        pyclass: L1BL2TransferVariables
        options:
            classifier:
                sigma0: [sig, sigma0]
                peakiness: [pp, pulse_peakiness]
                leading_edge_width: [lew, leading_edge_width]
                leading_edge_quality: [leq, leading_edge_quality]
                first_maximum_index: [fmi, first_maximum_index]
                first_maximum_power: [fmp, first_maximum_power]
                stack_standard_deviation: [ssd, stack_standard_deviation]
                stack_peakiness: [spk, stack_peakiness]
                stack_skewness: [ssk, stack_skewness]
                stack_kurtosis: [skt, stack_kurtosis]
                ocog_width: [ocogw, ocog_width]
                ocog_amplitude: [ocogp, ocog_amplitude]
            correction:
                dry_troposphere: [rcdt, dry_troposphere]
                wet_troposphere: [rcwt, wet_troposphere]
                dynamic_atmosphere: [rdac, dynamic_atmosphere]
                ionosphere: [rcio, ionosphere]
                ocean_tide_elastic: [rcote, ocean_tide_elastic]
                ocean_tide_long_period: [rcotlp, ocean_tide_long_period]
                ocean_loading_tide: [rcolt, ocean_loading_tide]
                solid_earth_tide: [rcset, solid_earth_tide]
                geocentric_polar_tide: [rcgpt,  geocentric_polar_tide]
            time_orbit:
                antenna_pitch: [toantptch, antenna_pitch]
                antenna_roll: [toantrll, antenna_roll]
                antenna_yaw: [toantyaw, antenna_yaw]
                orbit_flag: [tofl, orbit_flag]
            waveform:
                radar_mode: [rmwfm, radar_mode]
                is_valid: [flgwfm, flag_waveform_is_valid]

    # Compute rolling classifier statistics
    -   module: l2proc.procsteps
        pyclass: ParameterRollingStatistics
        options:
            window_size_m: 25000.
            statistics: ["sdev", "mean"]
            input_parameters:
                - pulse_peakiness
                - leading_edge_width
                - sigma0

    # --- Surface type classification algorithm ---
    #
    # Surface type classification algorithm can be fully constructed from the
    # config file. Only the land flag will always overwrite all classification after
    # the surface type classification.
    #
    # The conventions for the options are:
    #
    # <surface_type_code>:  -> [ocean, lead, sea_ice]
    #   - radar_mode: <radar_mode>
    #     exclude: <surface type>
    #     conditions:
    #         - logical expression of the type
    #              "{<parameter_name>} <operator> <value>"
    #           including the parameter name in {}, e.g.
    #              "{sea_ice_concentration} < 15.0"
    #           Fixed values as in example above are possible, but also monthly values, e.g.:
    #              "{sigma0} >= [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0, 11.0, 12.0]"
    #           This example is evaluated as "{sigma0} >= 1.0" for January and as
    #           "{sigma0} >= 12.0" for December.
    #
    #         - ...
    #   - ...

    # Surface type classification algorithm
    # SH: This is the surface type classification algorithm for
    #     the new ESA CCI climate data record. There are now significantly
    #     more sea ice waveform
    -   module: surface
        pyclass: ClassifierThresholdSurfaceType
        options:

            # This option defines the surface type order. It is important that
            # leads are classified before sea ice to fulfill the condition
            # that sea-ice waveforms are not lead waveforms.
            surface_types: [ocean, lead, sea_ice]

            # Ocean classification is based on a low pulse peakiness
            # and the sea-ice concentration based ice mask
            ocean:

                - radar_mode: lrm
                  conditions:
                      - "{sea_ice_concentration} < 15.0"

                - radar_mode: sar
                  conditions:
                      - "{sea_ice_concentration} < 15.0"
                      - "{pulse_peakiness_rolling_sdev} < 1.0"

                - radar_mode: sin
                  conditions:
                      - "{sea_ice_concentration} < 15.0"
                      - "{pulse_peakiness_rolling_sdev} < 4.0"

            # Lead waveforms are classified based on sigma0, leading edge width
            # and pulse peakiness within the sea-ice mask.
            # NOTE: No LRM data over sea ice
            lead:

                - radar_mode: sar
                  conditions:
                      - "{sea_ice_concentration} >= 15.0"
                      - "{pulse_peakiness} >= 66.0"
                      - "{sigma0} >= 23.0"
                      - "{leading_edge_width} <= 0.75"

                - radar_mode: sin
                  conditions:
                      - "{sea_ice_concentration} >= 15.0"
                      - "{pulse_peakiness} >= 260.0"
                      - "{sigma0} >= 24.0"
                      - "{leading_edge_width} <= 1.05"

            # The sea ice classification uses as many waveforms as possible
            # and reduces the classification to all waveforms within the
            # sea ice mask which are not classified as leads and have a
            # valid leading edge.
            sea_ice:

                - radar_mode: sar
                  exclude: lead
                  conditions:
                      - "{sea_ice_concentration} >= 15.0"
                      - "{leading_edge_quality} <= 1.02"

                - radar_mode: sin
                  exclude: lead
                  conditions:
                      - "{sea_ice_concentration} >= 15.0"
                      - "{leading_edge_quality} <= 1.02"

    # Retracking algorithm dependent on surface type
    -   module: retracker
        pyclass: Level2RetrackerContainer
        options:
          lead:
              pyclass: SAMOSAPlusRetracker
              options:
                surface_class: polar_ocean
                use_multiprocessing: True
                num_processes: "pysiral-cfg"
                fit_method: "samosap_specular"
                samosap_fit_kwargs:
                    # Two values for SAMOSA+ step1 and step2
                    # NOTE: step1 is ignored for leads (`fit_method: samosap_specular`)
                    amplitude_is_free_param: &samosa_fit_amp_lead [False, False]
                    # SAMOSA+ step 2 requires fixed swh value
                    step2_fixed_swh_value: 0.0
                    # Sub-waveform masking algorithm does not perform well for
                    # specular waveforms
                    trailing_edge_sub_waveform_filter: False
                predictor_kwargs:
                  amplitude_is_free_parameter: *samosa_fit_amp_lead
                  initial_guess:
                    epoch: first_maximum_index
                    amplitude: 1.0
                    nu: 2_000_000.0
                  bounds:
                    epoch:
                        earliest_range_window_fraction: 0.1
                        range_gates_after_fmi: 20
                    amplitude: [0.9, 1.1]
                    nu: [1_000_000., 1_000_000_000.]
                misfit_filter:
                    max_leading_edge_error: 0.1
                    max_misfit: 5.0

          sea_ice:
              pyclass: SAMOSAPlusRetracker
              options:
                surface_class: sea_ice
                use_multiprocessing: True
                num_processes: "pysiral-cfg"
                fit_method: "samosap_standard"
                samosap_fit_kwargs:
                    # Only single fit (with SAMOSA+ step 2)
                    amplitude_is_free_param: &samosa_fit_amp_sea_ice [True, True]
                    # SAMOSA+ step 1 requires fixed nu value
                    step1_fixed_nu_value: 0.0
                    # SAMOSA+ step 2 requires fixed swh value
                    step2_fixed_swh_value: 0.0
                    trailing_edge_sub_waveform_filter: True
                predictor_kwargs:
                  amplitude_is_free_parameter: *samosa_fit_amp_sea_ice
                  initial_guess:
                    epoch: first_maximum_index
                    amplitude: 1.0
                    swh: 2.0
                    nu: 10_000.
                  bounds:
                    epoch:
                        earliest_range_window_fraction: 0.1
                        range_gates_after_fmi: 20
                    amplitude: [0.9, 1.1]
                    swh: [-1.0, 10.0]
                    nu: [1_000., 10_000_000.]
                misfit_filter:
                    max_leading_edge_error: 0.1
                    max_misfit: 5.0

    # Apply the range corrections
    -   module: l2proc.procsteps
        pyclass: L2ApplyRangeCorrections
        options:
            corrections:
                - dry_troposphere
                - wet_troposphere
                - dynamic_atmosphere
                - ionosphere
                - ocean_tide_elastic
                - ocean_tide_long_period
                - ocean_loading_tide
                - solid_earth_tide
                - geocentric_polar_tide

    # Algorithm for instantaneous sea surface height (mss + ssa) and radar freeboard
    -   module: sla
        pyclass: SLASmoothedLinear
        options:
            use_ocean_wfm: False
            smooth_filter_width_m: 100000.0
            smooth_filter_width_footprint_size: 300.0
            tiepoint_elevation_filter:
                elevation_filter_window_m: 50000.
                upper_limit_standard_deviation: 2
                lower_limit_standard_deviation: 3
                minimum_standard_deviation_m: 0.1
            uncertainty_tiepoints_distance_max: 100000.
            uncertainty_minimum: 0.02
            uncertainty_maximum: 0.10
            marine_segment_filter:
                minimum_lead_number: 1
            tiepoint_maxdist_filter:
                maximum_distance_to_tiepoint: 200000.
                edges_only: False

    # Estimation of Radar Freeboard
    -   module: frb
        pyclass: RadarFreeboardDefault
        options: null

    # Filter out-of-valid range freeboard values
    -   module: filter
        pyclass: L2ParameterValidRange
        options:
            source_variable: afrb
            target_variables: [afrb]
            valid_minimum_point_value: -0.35
            valid_maximum_point_value: 2.35

    # Algorithm for converting radar freeboard into freeboard
    -   module: frb
        pyclass: SnowGeometricCorrection
        options:
            vacuum_light_speed_reduction: mallett2020

    # Filter out-of-valid range sea ice freeboard values
    -   module: filter
        pyclass: L2ParameterValidRange
        options:
            source_variable: frb
            target_variables: [frb]
            valid_minimum_point_value: -0.25
            valid_maximum_point_value: 2.25

    # Add a filter flag to detect anomalous freeboards in the marginal ice zone
    -   module: filter
        pyclass: SAMOSAMarginalIceZoneFilterFlag
        options:
            max_ocean_proximity: 150_000.0
            min_significant_waveheight: 3.2

    # Create a filtered/smoothed version of sea-ice freeboard
    -   module: filter
        pyclass: ParameterSmoother
        options:
            source_variable: frb
            target_variable_name: sea_ice_freeboard_filtered
            target_variable_id: frbflt
            smoothing_method: lowess
            smoother_args:
#                # The lowess filter size in statsmodels implementation uses
#                # in fractions of data points to determine the filter size
#                # The lowess filter therefore computes the data fraction
#                # from the `filter_size_n_points` keyword
                filter_size_n_points: 83
                filter_props:
                     it: 1

    # Create an instrument mode flag for CryoSat-2 data
    # (instrument mode = radar mode + 1)
    -   module: l2proc.procsteps
        pyclass: CS2InstrumentModeflag
        options: null
